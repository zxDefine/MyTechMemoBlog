# 解码方法
## 题目
>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
>> 'A' -> 1
>>'B' -> 2
>>\.\.\.
>>'Z' -> 26
>>
>要**解码**已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
>>* "AAJF" ，将消息分组为 (1 1 10 6)
>>* "KJF" ，将消息分组为 (11 10 6)
>
>注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
>给你一个只含数字的**非空**字符串 s ，请计算并返回**解码**方法的**总数** 。
>题目数据保证答案肯定是一个**32 位**的整数。
>>
>>示例 1:
>>	输入：s = "12"
>>	输出：2
>>    解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
>>
>>示例 2:
>>	输入: s = "226"
>>	输出: 3
>>    解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
>>
>>示例 3:
>>   输入：s = "0"
>>   输出：0
>>   解释：没有字符映射到以 0 开头的数字。
>>   含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
>>   由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
>>示例 4:
>>    输入：s = "06"
>>    输出：0
>>    解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
>>
>>>提示:
>>>* 1 \<= s.length \<= 100
>>>* s 只包含数字，并且可能包含前导零。

## 可以在这里确认
->[LeetCode 91 解码方法](https://leetcode-cn.com/problems/decode-ways/)

## 思考
这道题还是很让我思考了一段时间，最后参考了各位大神的解答，在加上自己的理解，最后终于搞懂了这道题。
首先使用的方法是动态规划。假设dp[i]，是指字符串s的**前**i个字符所有的解码方法总数。那么在再看位置i，这个位置上的字符又要分2种情况。
* 用位置i的字符单独解码的时候，只要s[i] != '0'，那么就是可以解码成功，此时的dp[i] = dp[i-1]。因为dp[i-1]的某种解码方法中再加上字符是s[i]，就成为了dp[i]的某种解码方法了，解码方法总数并不改变。
* 用位置i跟位置i-1的字符组合解码的时候，则需要稍稍复杂点，需要判单位置i-1不能是'0'，并且位置i跟位置i-1字符组合起来数值小于等于26。都满足的话，dp[i] = dp[i -2]，理由同上。

因为是求解码总数，所以把上述的两个所得加起来即可。
有两个注意点，第一是空字符串的解码数是1，它本身也是一种解码，即dp[0]=1。第二就是i代表前多少个位置的字符的意思，用在字符串s的索引的时候需要减一。
因为只跟位置i、位置i-1、位置i-2有关系，所以不需要数组，只需要记住这三个数值即可，方法如下。

## 解题思路
1. 创建3个记住dp的变量dpCurr、dpPre、dpSpre。
2. 然后从第1个位置遍历到s.length的位置。
3. 判断一个字符的情况，如果s[i-1]!='0'，则dpCurr=dpPre
4. 判断两个字符的情况，如果i>1且s[i-2]!='0'且s[i-2]<='2',s[i-1]<='6，则'dpCurr=dpSpre
5. 然后把两个dpCurr相加即的结果。

## Python

```python
	class Solution:
    def numDecodings(self, s: str) -> int:
        dpSPre, dpPre, dpCurr = 0, 1, 0
        for i in range(1,len(s) + 1):
            dpCurr = 0
            if s[i - 1] != '0':
                dpCurr = dpPre
            if i > 1 and s[i - 2] != '0' and int(s[i-2: i]) <= 26:
                dpCurr += dpSPre 
            dpSPre, dpPre = dpPre, dpCurr
        return dpCurr
```

执行用时：44 ms, 在所有 Python3 提交中击败了46.01%的用户
内存消耗：15 MB, 在所有 Python3 提交中击败了31.98%的用户

## C++

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int dpSpre = 0;
        int dpPre = 1;
        int dpCurr = 0;
        for(int i = 1; i <= s.length(); ++i){
            dpCurr=0;
            if(s[i - 1] != '0') dpCurr = dpPre;
            if((i > 1) && (s[i - 2] != '0') 
            && (('1' >= s[i - 2]) || (('2' >= s[i - 2]) && ('6' >= s[i - 1] )))){
                dpCurr += dpSpre;
            }
            dpSpre = dpPre;
            dpPre = dpCurr;
        }
        return dpCurr;
    }
};
```

执行用时：4 ms, 在所有 C++ 提交中击败了37.64%的用户
内存消耗：6 MB, 在所有 C++ 提交中击败了78.70%的用户

## Kotlin

```kotlin
class Solution {
    fun numDecodings(s: String): Int {
        var dpSpre = 0
        var dpPre = 1
        var dpCurr = 0
        for(i in 1..s.length step 1){
            dpCurr = 0
            if(s[i - 1] != '0') dpCurr = dpPre
            if(((i > 1) && (s[i - 2] != '0')) && (('1' >= s[i - 2]) || (('2' >= s[i - 2]) && ('6' >= s[i - 1] )))){
                dpCurr += dpSpre
            }
            dpSpre = dpPre
            dpPre = dpCurr
        }
        return dpCurr
    }
}
```

执行用时：188 ms, 在所有 Kotlin 提交中击败了50.00%的用户
内存消耗：33.2 MB, 在所有 Kotlin 提交中击败了15.00%的用户