# 关于const、readonly与sealed

## 参考资料
本文出自CSDN作者WhiteJunior,[**原文**](https://blog.csdn.net/lym940928/article/details/88386224)出处,这里只为自己方便查看转载。

## const与readonly
在C#中,二者都将变量声明为只读 ,并且在变量初始化后就**不可以改写**。

不同点主要涉及到以下两个常量类型:

* 静态常量(compile-time constants)
> 指编译器在编译时候会对常量进行解析,并将常量的值替换成初始化的那个值。
* 动态常量(runtime constants)
> 动态常量的值则是在运行的那一刻才获得的,编译器编译期间将其标识为只读常量,而不用常量的值代替,这样动态常量不必在声明的时候就初始化,而可以延迟到**构造函数**中初始化。

对于const,其修饰的常量类型为**静态常量**;
对于readonly,其修饰的常量类型为**动态常量**。

* const修饰的常量在声明的时候**必须初始化**;readonly修饰的常量则可以**延迟到构造函数初始化**;
* const修饰的常量在编译期间就被解析,即常量值被替换成初始化的值;readonly常量**只能声明在类中**;
* const常量既可以声明在类中,也可以在函数体中;但是static readonly常量**只能声明在类中**。

因此,对于二者,相同点在于:

* const和readonly都是只读的。
* const默认是static的,而且在编译期间已经解析完成。因此const和static readonly**只能有类访问**,而readonly**通过实例访问**。

不同点在于:

* **const既可以修饰类中的成员,又可以修饰函数体中的成员;而readonly只能修饰类中的成员**。
* **const(静态常量)只能声明为简单的数据类型,如int、浮点型、枚举型、布尔型、字符串型;而readonly(动态常量)则可以修饰对象类型**。

需要注意的是:

* const默认是静态的,**不能用所谓的“static const”**、
* static readonly常量,**如果要在构造函数中初始化其值,也必须在静态无参构造函数中初始化**。

小结:

* const是静态常量,readonly是动态常量。
* const高效,readonly灵活。
* 实际使用中,常常用static readonly来代替const,以此来平衡const在灵活性上的不足。

## sealed
sealed,即密封类和密封方法。
在C#中允许把类和方法声明为**sealed**。

* **对于类,则表明不能继承该类**。
* **对于方法,则表示不能再次重写该方法**。

在方法中使用sealed,只能是在**已经被重写的方法**中定义sealed,表示这个方法不可以再被重写。

密封类和密封方法的作用,是防止重写某些类导致代码的混乱,或者一些出于商业上的原因。